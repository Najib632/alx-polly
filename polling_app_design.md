# Polling App System Design (Next.js + Supabase + Vercel)

## High-level system architecture

### Frontend (Next.js on Vercel)
- **App Router** with Server Components (RSC-first rendering).
- **Server Actions** for mutations (poll creation, voting, closing polls).
- **Route Handlers** (`app/api/*`) for QR generation, webhooks, and redirects.
- **Realtime UI** powered by Supabase Realtime subscriptions.
- **Auth** integrated with Supabase Auth (OAuth, passkeys, email magic links).
- **Caching** using `revalidatePath`/`revalidateTag` + Vercel CDN.

### Backend (Supabase)
- **Postgres** as primary DB.
- **Auth & RLS** policies for secure access control.
- **Realtime** (Postgres CDC) for live updates.
- **RPC functions** for atomic actions like voting.
- **Triggers/materialized views** for efficient vote counts.

### Infra & Edge
- **Vercel Edge Runtime** for QR code generation and fast GET routes.
- **Rate limiting & bot protection**: Upstash Redis + Cloudflare Turnstile.
- **Monitoring**: Vercel Analytics, PostHog, Sentry.

---

## Project structure

```
app/
  (marketing)/
    page.tsx
  (app)/
    layout.tsx
    dashboard/page.tsx
    polls/
      new/page.tsx
      [pollId]/
        page.tsx
        results/page.tsx
  p/[shortCode]/page.tsx            # short link redirect
  api/
    qr/route.ts                     # QR generation
    webhooks/supabase/route.ts      # optional webhook intake
components/
  PollCreator.tsx
  PollCard.tsx
  VoteWidget.tsx
  QRButton.tsx
lib/
  supabase/client-browser.ts
  supabase/client-server.ts
  auth.ts
  polling.ts
  rate-limit.ts
  zod.ts
server/
  actions.ts                        # createPoll, castVote, closePoll
  rls.ts                            # auth + RLS helpers
database/
  schema.sql
styles/
  globals.css
```

---

## Database schema

### Polls
```sql
create table public.polls (
  id uuid primary key default gen_random_uuid(),
  owner_id uuid not null references auth.users(id) on delete cascade,
  title text not null,
  description text,
  is_anonymous boolean default false,
  allow_multiple boolean default false,
  max_choices int default 1,
  slug text generated always as (replace(lower(title), ' ', '-')) stored,
  short_code text unique default substr(md5(gen_random_uuid()::text), 1, 8),
  starts_at timestamptz default now(),
  ends_at timestamptz,
  is_closed boolean default false,
  created_at timestamptz default now()
);
```

### Poll options
```sql
create table public.poll_options (
  id uuid primary key default gen_random_uuid(),
  poll_id uuid not null references public.polls(id) on delete cascade,
  label text not null,
  idx int not null,
  unique(poll_id, idx)
);
```

### Votes
```sql
create table public.votes (
  id bigint generated by default as identity primary key,
  poll_id uuid not null references public.polls(id) on delete cascade,
  option_id uuid not null references public.poll_options(id) on delete cascade,
  voter_uid uuid,
  anon_fingerprint text,
  created_at timestamptz default now()
);

-- One vote per user per poll
create unique index votes_unique_user_per_poll
  on public.votes(poll_id, voter_uid)
  where voter_uid is not null;

-- One vote per anonymous fingerprint per poll
create unique index votes_unique_anon_per_poll
  on public.votes(poll_id, anon_fingerprint)
  where anon_fingerprint is not null;
```

### Views (optional for performance)
```sql
create view public.poll_option_counts as
select o.id as option_id, o.poll_id, count(v.id) as votes
from poll_options o
left join votes v on v.option_id = o.id
group by o.id, o.poll_id;
```

---

## Row Level Security (RLS)

```sql
alter table polls enable row level security;
alter table poll_options enable row level security;
alter table votes enable row level security;

-- Polls: readable by all, writable by owner
create policy "polls are readable by all"
  on polls for select using (true);

create policy "polls: owners can manage"
  on polls for all
  using (auth.uid() = owner_id)
  with check (auth.uid() = owner_id);

-- Poll options: readable by all, writable by poll owner
create policy "options readable by all"
  on poll_options for select using (true);

create policy "options writable by owner"
  on poll_options for all
  using (exists (select 1 from polls p where p.id = poll_options.poll_id and p.owner_id = auth.uid()));

-- Votes: readable by all, insert restricted
create policy "votes readable"
  on votes for select using (true);

create policy "user can insert one vote"
  on votes for insert
  with check (
    voter_uid = auth.uid()
    and not exists (
      select 1 from votes v
      where v.poll_id = votes.poll_id
        and v.voter_uid = auth.uid()
    )
  );

create policy "anon can insert one vote"
  on votes for insert
  with check (
    anon_fingerprint is not null
    and exists (
      select 1 from polls p
      where p.id = votes.poll_id and p.is_anonymous = true
    )
    and not exists (
      select 1 from votes v
      where v.poll_id = votes.poll_id
        and v.anon_fingerprint = votes.anon_fingerprint
    )
  );
```

---

## RPC for voting

```sql
create or replace function public.cast_vote(
  p_poll_id uuid,
  p_option_id uuid,
  p_anon_fingerprint text default null
) returns void
language plpgsql
security definer
as $$
declare poll record;
begin
  select * into poll from polls where id = p_poll_id;
  if poll is null or poll.is_closed then
    raise exception 'Poll not open';
  end if;

  if auth.uid() is null then
    if not poll.is_anonymous then
      raise exception 'Authentication required';
    end if;
    insert into votes(poll_id, option_id, anon_fingerprint)
    values (p_poll_id, p_option_id, p_anon_fingerprint)
    on conflict do nothing;
  else
    insert into votes(poll_id, option_id, voter_uid)
    values (p_poll_id, p_option_id, auth.uid())
    on conflict do nothing;
  end if;
end $$;
```

---

## QR Code integration

### Short code in poll
- `short_code` column created on poll insert.
- Public link: `https://yourapp.com/p/[short_code]`.

### Route handler for QR generation
```ts
// app/api/qr/route.ts
import QRCode from "qrcode";

export const runtime = "edge";

export async function GET(req: Request) {
  const { searchParams } = new URL(req.url);
  const code = searchParams.get("code");
  if (!code) return new Response("Missing code", { status: 400 });

  const pollUrl = `${process.env.APP_URL}/p/${code}`;
  const svg = await QRCode.toString(pollUrl, { type: "svg", margin: 1 });

  return new Response(svg, {
    headers: {
      "Content-Type": "image/svg+xml",
      "Cache-Control": "public, max-age=31536000, immutable",
    },
  });
}
```

### Short link redirect
```ts
// app/p/[shortCode]/page.tsx
import { supabaseServer } from "@/lib/supabase/client-server";
import { redirect } from "next/navigation";

export default async function ShortLink({ params }) {
  const supabase = supabaseServer();
  const { data: poll } = await supabase
    .from("polls")
    .select("id")
    .eq("short_code", params.shortCode)
    .single();

  if (!poll) redirect("/");
  redirect(`/polls/${poll.id}`);
}
```

---

## Tools & libraries
- **UI**: Tailwind CSS + shadcn/ui + Radix UI.
- **Validation**: Zod.
- **State mgmt**: RSC + SWR or React Query.
- **Supabase**: `@supabase/supabase-js`, `@supabase/auth-helpers-nextjs`.
- **QR codes**: `qrcode` (SVG/PNG generation).
- **Scanning**: `@zxing/browser` or `jsQR`.
- **Rate limiting**: Upstash Redis or Vercel KV.
- **Monitoring**: Sentry, PostHog, Vercel Analytics.
- **Testing**: Vitest + Playwright.

---

## Scalability considerations
- **DB**: unique indexes + RLS prevent duplicate votes.
- **Realtime**: subscribe per poll (`votes` table changes).
- **Caching**: Vercel CDN caches QR codes and static content.
- **Perf**: for hot polls, use materialized counts instead of live aggregation.

---

## Development plan

1. **MVP**
   - Poll creation, voting, live results, QR sharing.
2. **Security**
   - RLS policies, rate limiting, bot protection.
3. **Optimization**
   - Materialized counts, caching, CDN tuning.
4. **Enhancements**
   - Poll scheduling, team features, CSV exports.

