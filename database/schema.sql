-- ======================================================
-- Complete polling app schema, constraints, RLS & RPC
-- ======================================================

-- Ensure pgcrypto (for gen_random_uuid())
CREATE EXTENSION IF NOT EXISTS pgcrypto;

-- ----------------------
-- Cleanup (safe to run)
-- ----------------------
DROP VIEW IF EXISTS public.poll_option_counts;
DROP TABLE IF EXISTS public.votes CASCADE;
DROP TABLE IF EXISTS public.poll_options CASCADE;
DROP TABLE IF EXISTS public.polls CASCADE;

-- ----------------------
-- Polls table
-- ----------------------
CREATE TABLE public.polls (
  id             uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  owner_id       uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  question       text NOT NULL,
  title          text NOT NULL,
  description    text,
  is_anonymous   boolean DEFAULT false,
  allow_multiple boolean DEFAULT false,
  max_choices    int DEFAULT 1,
  slug           text GENERATED ALWAYS AS (replace(lower(question), ' ', '-')) STORED,
  short_code     text UNIQUE DEFAULT substr(md5(gen_random_uuid()::text), 1, 8),
  starts_at      timestamptz DEFAULT now(),
  ends_at        timestamptz,
  is_closed      boolean DEFAULT false,
  created_at     timestamptz DEFAULT now()
);

-- ----------------------
-- Poll options table
-- ----------------------
CREATE TABLE public.poll_options (
  id        uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  poll_id   uuid NOT NULL REFERENCES public.polls(id) ON DELETE CASCADE,
  label     text NOT NULL,
  idx       int NOT NULL,
  created_at timestamptz DEFAULT now(),
  UNIQUE (poll_id, idx)
);

-- add a composite unique needed for the composite FK below
ALTER TABLE public.poll_options
  ADD CONSTRAINT poll_options_pollid_id_unique UNIQUE (poll_id, id);

-- ----------------------
-- Votes table
-- ----------------------
CREATE TABLE public.votes (
  id               bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  poll_id          uuid NOT NULL,
  option_id        uuid NOT NULL,
  voter_uid        uuid,
  anon_fingerprint text,
  created_at       timestamptz DEFAULT now()
);

-- Enforce option belongs to poll via composite foreign key:
ALTER TABLE public.votes
  ADD CONSTRAINT votes_option_belongs_to_poll
  FOREIGN KEY (poll_id, option_id)
  REFERENCES public.poll_options (poll_id, id)
  ON DELETE CASCADE;

-- Per-option uniqueness: prevents duplicate votes for the same option by same user/fingerprint
CREATE UNIQUE INDEX IF NOT EXISTS votes_unique_user_per_option
  ON public.votes(poll_id, option_id, voter_uid)
  WHERE voter_uid IS NOT NULL;

CREATE UNIQUE INDEX IF NOT EXISTS votes_unique_anon_per_option
  ON public.votes(poll_id, option_id, anon_fingerprint)
  WHERE anon_fingerprint IS NOT NULL;

-- Extra indexes
CREATE INDEX IF NOT EXISTS idx_votes_poll_id ON public.votes(poll_id);
CREATE INDEX IF NOT EXISTS idx_votes_option_id ON public.votes(option_id);
CREATE INDEX IF NOT EXISTS idx_polls_owner_id ON public.polls(owner_id);

-- ----------------------
-- Aggregated view (counts include options with zero votes)
-- ----------------------
-- Note: 'security_invoker' on views requires PG15+. If you are on older PG, remove the WITH (...) clause.
CREATE OR REPLACE VIEW public.poll_option_counts
WITH (security_invoker = on)
AS
SELECT
  o.poll_id,
  o.id AS option_id,
  o.label AS option_label,
  COUNT(v.id) AS vote_count
FROM public.poll_options o
LEFT JOIN public.votes v ON v.option_id = o.id
GROUP BY o.poll_id, o.id, o.label;

-- ----------------------
-- Enable Row-Level Security on tables
-- ----------------------
ALTER TABLE public.polls ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.poll_options ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.votes ENABLE ROW LEVEL SECURITY;

-- ----------------------
-- POLICIES: Polls
-- ----------------------
-- remove overly-restrictive old policy if present
DROP POLICY IF EXISTS "Poll owners can see their polls" ON public.polls;

-- Everyone (anon or auth) can SELECT polls (public / discoverable)
CREATE POLICY "polls are readable by all"
  ON public.polls FOR SELECT
  USING (true);

-- Only authenticated users may create polls; owner_id must equal session user
CREATE POLICY "authenticated users can insert polls"
  ON public.polls FOR INSERT
  WITH CHECK (auth.uid() = owner_id);

-- Only owners can update their polls, and they cannot change owner_id to someone else
CREATE POLICY "poll owners can update polls"
  ON public.polls FOR UPDATE
  USING (owner_id = auth.uid())
  WITH CHECK (owner_id = auth.uid());

-- Only owners can delete their polls
CREATE POLICY "poll owners can delete polls"
  ON public.polls FOR DELETE
  USING (owner_id = auth.uid());

-- ----------------------
-- POLICIES: Poll options
-- ----------------------
-- Everyone can read poll options
CREATE POLICY "poll options are readable by all"
  ON public.poll_options FOR SELECT
  USING (true);

-- Only poll owners may insert options for their poll
CREATE POLICY "poll owners can insert options"
  ON public.poll_options FOR INSERT
  WITH CHECK (EXISTS (
    SELECT 1 FROM public.polls p
    WHERE p.id = poll_options.poll_id AND p.owner_id = auth.uid()
  ));

-- Only owners can update options (and ensure they remain tied to the same poll/owner)
CREATE POLICY "poll owners can update options"
  ON public.poll_options FOR UPDATE
  USING (EXISTS (
    SELECT 1 FROM public.polls p
    WHERE p.id = poll_options.poll_id AND p.owner_id = auth.uid()
  ))
  WITH CHECK (EXISTS (
    SELECT 1 FROM public.polls p
    WHERE p.id = poll_options.poll_id AND p.owner_id = auth.uid()
  ));

-- Only owners can delete options
CREATE POLICY "poll owners can delete options"
  ON public.poll_options FOR DELETE
  USING (EXISTS (
    SELECT 1 FROM public.polls p
    WHERE p.id = poll_options.poll_id AND p.owner_id = auth.uid()
  ));

-- ----------------------
-- POLICIES: Votes
-- ----------------------
-- Restrict SELECT on raw votes: only poll owners and the voter can read individual vote rows.
-- (Frontend should read aggregated counts from poll_option_counts view.)
CREATE POLICY "poll owners and voters can view votes"
  ON public.votes FOR SELECT
  USING (
    poll_id IN (SELECT id FROM public.polls WHERE owner_id = auth.uid())
    OR voter_uid = auth.uid()
  );

-- Deny direct INSERT into votes table (force use of cast_vote() RPC).
CREATE POLICY "deny direct votes insert"
  ON public.votes FOR INSERT
  WITH CHECK (false);

-- Disallow UPDATEs to votes
CREATE POLICY "deny votes update"
  ON public.votes FOR UPDATE
  USING (false);

-- Allow DELETE by poll owner OR by the voter themself (optional; use with care)
CREATE POLICY "votes can be deleted by owner or voter"
  ON public.votes FOR DELETE
  USING (
    poll_id IN (SELECT id FROM public.polls WHERE owner_id = auth.uid())
    OR voter_uid = auth.uid()
  );

-- ----------------------
-- RPC: cast_vote
-- ----------------------
-- Important: cast_vote is SECURITY DEFINER. Ensure its owner is a role allowed to bypass RLS
-- in your environment (Supabase typically uses a privileged role for functions).
CREATE OR REPLACE FUNCTION public.cast_vote(
  p_poll_id uuid,
  p_option_id uuid,
  p_anon_fingerprint text DEFAULT NULL
) RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  poll_record RECORD;
  voter uuid;
  existing_votes int;
BEGIN
  -- Load poll
  SELECT * INTO poll_record FROM public.polls WHERE id = p_poll_id;
  IF poll_record IS NULL THEN
    RAISE EXCEPTION 'Poll not found';
  END IF;

  -- Check poll open window
  IF poll_record.is_closed
     OR (poll_record.starts_at IS NOT NULL AND poll_record.starts_at > now())
     OR (poll_record.ends_at   IS NOT NULL AND poll_record.ends_at   < now()) THEN
    RAISE EXCEPTION 'Poll not open';
  END IF;

  -- Ensure option belongs to poll
  IF NOT EXISTS (SELECT 1 FROM public.poll_options WHERE id = p_option_id AND poll_id = p_poll_id) THEN
    RAISE EXCEPTION 'Option does not belong to poll';
  END IF;

  voter := auth.uid();

  IF voter IS NULL THEN
    -- Anonymous path
    IF NOT COALESCE(poll_record.is_anonymous, false) THEN
      RAISE EXCEPTION 'Authentication required for this poll';
    END IF;

    IF p_anon_fingerprint IS NULL THEN
      RAISE EXCEPTION 'Anonymous fingerprint required';
    END IF;

    -- Enforce choice limits
    IF COALESCE(poll_record.allow_multiple, false) THEN
      IF COALESCE(poll_record.max_choices, 1) > 0 THEN
        SELECT COUNT(*) INTO existing_votes
         FROM public.votes
         WHERE poll_id = p_poll_id AND anon_fingerprint = p_anon_fingerprint;
        IF existing_votes >= poll_record.max_choices THEN
          RAISE EXCEPTION 'Vote limit reached';
        END IF;
      END IF;
    ELSE
      IF EXISTS (SELECT 1 FROM public.votes WHERE poll_id = p_poll_id AND anon_fingerprint = p_anon_fingerprint) THEN
        RAISE EXCEPTION 'Already voted';
      END IF;
    END IF;

    BEGIN
      INSERT INTO public.votes (poll_id, option_id, anon_fingerprint)
      VALUES (p_poll_id, p_option_id, p_anon_fingerprint);
    EXCEPTION WHEN unique_violation THEN
      RAISE EXCEPTION 'Already voted';
    END;

  ELSE
    -- Authenticated path
    IF COALESCE(poll_record.allow_multiple, false) THEN
      IF COALESCE(poll_record.max_choices, 1) > 0 THEN
        SELECT COUNT(*) INTO existing_votes
         FROM public.votes
         WHERE poll_id = p_poll_id AND voter_uid = voter;
        IF existing_votes >= poll_record.max_choices THEN
          RAISE EXCEPTION 'Vote limit reached';
        END IF;
      END IF;
    ELSE
      IF EXISTS (SELECT 1 FROM public.votes WHERE poll_id = p_poll_id AND voter_uid = voter) THEN
        RAISE EXCEPTION 'Already voted';
      END IF;
    END IF;

    BEGIN
      INSERT INTO public.votes (poll_id, option_id, voter_uid)
      VALUES (p_poll_id, p_option_id, voter);
    EXCEPTION WHEN unique_violation THEN
      RAISE EXCEPTION 'Already voted';
    END;
  END IF;
END;
$$;

-- Grant execute so client sessions can call the RPC via Supabase client
GRANT EXECUTE ON FUNCTION public.cast_vote(uuid, uuid, text) TO authenticated, anon;

-- ----------------------
-- (Optional) convenience: allow the service role to refresh materialized counts, etc.
-- ----------------------
-- GRANT EXECUTE ON FUNCTION public.cast_vote(...) TO service_role; -- only if you have a service role

-- ======================================================
-- Done.
-- ======================================================
